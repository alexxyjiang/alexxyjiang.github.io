{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/my-understanding-of-consistent-hashing/","result":{"data":{"markdownRemark":{"id":"05b14631-7142-5681-b262-d06d3165f18e","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cce3a4f1f6e7680a73f8fb2ffaae095a/4b190/consistent-hashing.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB3XXKAYf/xAAZEAADAAMAAAAAAAAAAAAAAAAAAjIRQUL/2gAIAQEAAQUC0ZO3lZ//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAR/9oACAEBAAY/AtqiP//EABkQAAMBAQEAAAAAAAAAAAAAAAABETFhof/aAAgBAQABPyHYMtc4Nk5o8jQ8B//aAAwDAQACAAMAAAAQGO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAgICAwAAAAAAAAAAAAABABExQSFRcYGR/9oACAEBAAE/EBcpqzqNG9XatxVonjEVPk4KZBp9TI7E/9k='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/cce3a4f1f6e7680a73f8fb2ffaae095a/8ac56/consistent-hashing.webp 240w,\n/static/cce3a4f1f6e7680a73f8fb2ffaae095a/d3be9/consistent-hashing.webp 480w,\n/static/cce3a4f1f6e7680a73f8fb2ffaae095a/d00b9/consistent-hashing.webp 800w\"\n              sizes=\"(max-width: 800px) 100vw, 800px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/cce3a4f1f6e7680a73f8fb2ffaae095a/09b79/consistent-hashing.jpg 240w,\n/static/cce3a4f1f6e7680a73f8fb2ffaae095a/7cc5e/consistent-hashing.jpg 480w,\n/static/cce3a4f1f6e7680a73f8fb2ffaae095a/4b190/consistent-hashing.jpg 800w\"\n            sizes=\"(max-width: 800px) 100vw, 800px\"\n            type=\"image/jpeg\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/cce3a4f1f6e7680a73f8fb2ffaae095a/4b190/consistent-hashing.jpg\"\n            alt=\"Consistent Hashing\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>In computer science, <strong>consistent hashing</strong> is a special kind of hashing technique such that when a hash table is resized, only <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0404em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> keys need to be remapped on average, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the number of keys and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> is the number of slots. This is in contrast to traditional hash tables, where a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p>\n<p>We use consistent hashing to distribute data across a cluster of nodes. The main idea is to use a hash function to map both the keys and the nodes to a fixed-size space (usually a circle). When a new node is added or removed, only a few keys need to be remapped, which minimizes the disruption to the system.</p>\n<h2 id=\"main-supported-operations\" style=\"position:relative;\"><a href=\"#main-supported-operations\" aria-label=\"main supported operations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Main Supported Operations</h2>\n<ol>\n<li><strong>Insert <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span> into the cluster</strong>: To insert a new data item, we first compute its hash value and find the node responsible for that hash value. This is done by finding the successor of the hash value in the hash ring.</li>\n<li><strong>Delete <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span> from the cluster</strong>: To delete a data item, we find the node responsible for that item using its hash value and remove it from that node.</li>\n<li><strong>Get <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span> from the cluster</strong>: To retrieve a data item, we compute its hash value and find the node responsible for that hash value. We then retrieve the data item from that node.</li>\n<li><strong>Insert a server into the cluster</strong>: When a new server is added, we compute its hash value and find the keys that need to be moved to the new server. This is done by finding the successor of the hash value in the hash ring.</li>\n<li><strong>Delete a server from the cluster</strong>: When a server is removed, we find the successor of its hash value and move the keys from the removed server to the successor server.</li>\n<li><strong>Get all data from a server</strong>: To retrieve all data items from a specific server, we can iterate through the data items stored on that server and return them.</li>\n<li><strong>Get all servers in the cluster</strong>: To retrieve all servers, we can iterate through the nodes in the cluster and return their identifiers.</li>\n</ol>","fields":{"slug":"/posts/2024-04-29---My-Understanding-of-Consistent-Hashing//posts/my-understanding-of-consistent-hashing","tagSlugs":["/tag/data-processing/","/tag/distributed-storage-structure/"]},"frontmatter":{"date":"2024-04-29T15:00:00.000Z","description":"consistent hashing is a widely used hashing technique in distributed systems.","tags":["Data Processing","Distributed Storage Structure"],"title":"My Understanding of Consistent Hashing","socialImage":{"publicURL":"/static/cce3a4f1f6e7680a73f8fb2ffaae095a/consistent-hashing.jpg"}}}},"pageContext":{"slug":"/posts/2024-04-29---My-Understanding-of-Consistent-Hashing//posts/my-understanding-of-consistent-hashing"}},"staticQueryHashes":["251939775","288581551","401334301"],"slicesMap":{}}